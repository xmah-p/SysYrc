# 编译原理课程实践报告：SysYrc

元培学院 2200017768 杨艺欣

## 一、编译器概述

### 1.1 基本功能

本编译器（SysYrc, SysY **r**ust **c**ompiler）具备如下功能：
1. 将 SysY 语言编译为 Koopa IR 代码。
2. 将 Koopa IR 代码进一步编译为 RISC-V 汇编代码。

### 1.2 主要特点

本编译器的主要特点是**内存安全**、**实现清晰优雅**、**注释完备扼要**。
- **内存安全**：本编译器完全使用 Rust 语言实现，且无 `unsafe` 代码块，杜绝了内存安全问题。
- **实现清晰优雅**：本编译器的代码架构清晰，模块职责分明，最大限度地消除了冗余代码，可读性和可维护性极强。
- **注释完备扼要**：本编译器的代码注释完备而不冗长，大部分代码做到了 self-explanatory，小部分难理解的代码均有简洁明了的注释。

## 二、编译器设计

### 2.1 主要模块组成

编译器由3个主要模块组成：
- **Parser**：负责将 SysY 源代码解析为自定义的抽象语法树（AST），使用 `lalrpop` 作为语法分析器生成工具。
- **前端**：负责将 AST 转换为 Koopa IR 代码，实现了**上下文数据**和**具体转换逻辑**的解耦。
- **后端**：负责将 Koopa IR 代码转换为 RISC-V 汇编，程序级翻译和函数级翻译分离。

### 2.2 主要数据结构

本编译器的核心数据结构包括 AST、前端 Koopa IR 生成的上下文数据结构、后端的栈帧数据结构。

一个 SysY 程序可被解析为一棵以 `CompUnit` 为根的 AST：

```rust
// AST 主要节点定义（部分节点省略）
pub struct CompUnit {
    pub items: Vec<GlobalItem>,
}

pub enum GlobalItem {
    Decl(Decl),    // Global variable/constant declaration
    FuncDef(FuncDef),    // Function definition
}

pub struct FuncDef {
    pub func_type: FuncType,
    pub func_name: String,
    pub params: Vec<FuncFParam>,
    pub block: Block,
}

pub struct Block {
    pub items: Vec<BlockItem>,
}

pub enum BlockItem {
    Decl(Decl),
    Stmt(Stmt),
}

pub enum Decl {
    Const {
        ...
    },
    Var {
        ...
    },
    Array {
        ...
    },
    ConstArray {
        ...
    }
}

pub enum Stmt {
    Return {
        ...
    },
    Assign {
        ...
    },
    Expression {
        ...
    },
    Block {
        ...
    },
    If {
        ...
    },
    While {
        ...
    },
    Break,
    Continue,
}

pub enum Expr {
    Binary {
        ...
    },
    Unary {
        ...
    },
    LVal {
        ...
    },
    Call {
        ...
    },
    Number(i32),
}
```

解析 AST 生成 Koopa IR 的过程中，本编译器维护了一个上下文数据结构 `KoopaContext`，用于存储当前符号表、当前的全局/函数级/基本块级信息。它和具体的翻译逻辑（`KoopaGenerator`）解耦.

```rust
pub struct KoopaContext<'a> {
    pub program: &'a mut Program,    // Koopa IR program being built
    pub symbol_table: SymbolTable,    // Current symbol table
    current_func: Option<Function>,    // Current function being processed
    current_bb: Option<BasicBlock>,    // Current basic block being processed
    bb_count: usize, // For generating unique basic block names
    // These two stacks are used to keep track of the current loop's
    // break and continue targets
    // For while loops, they should always be operated in pairs
    loop_break_stack: Vec<BasicBlock>,
    loop_continue_stack: Vec<BasicBlock>,
}
```

在后端，生成函数栈帧时，本编译器维护了一个 `StackFrame` 数据结构，用于存储函数栈帧相关信息。基于此数据结构，后端能够正确地为每个函数分配栈空间，保存和恢复寄存器。

```rust
pub struct StackFrame {
    values_map: HashMap<Value, i32>, // Map Koopa IR Values to their stack offsets
    stack_size: i32,                 // Total size of the stack frame
    ra_offset: Option<i32>,          // Offset for the return address if saved
}
```

在 `if...else...` 语句方面，由于涉及到二义性问题，所以本编译器在 lalrpop 语法定义中通过区分已匹配的语句和开放的语句来解决该问题：

```rust
// lalrpop 语法定义片段
Stmt: Stmt = {
    MatchedStmt,
    OpenStmt,
}

MatchedStmt: Stmt = {
    // ... 省略各种非 if 语句（如 return, assign, while 等）
    "if" "(" <cond: Expr> ")" <then_body: MatchedStmt> "else" <else_body: MatchedStmt> => Stmt::If {
        cond,
        then_body: Box::new(then_body),
        else_body: Some(Box::new(else_body)),
    },
};

OpenStmt: Stmt = {
    // Case A: No else
    // Only when there's no else, we can allow then_body to be OpenStmt
    "if" "(" <cond: Expr> ")" <then_body: Stmt> => {
        Stmt::If {
            cond,
            then_body: Box::new(then_body),
            else_body: None,
        }
    },

    // Case B: With else, but else_body is OpenStmt
    // then_body must be MatchedStmt here, otherwise else would be parsed as belonging to then_body
    // instead of the current if.
    "if" "(" <cond: Expr> ")" <then_body: MatchedStmt> "else" <else_body: OpenStmt> => {
        Stmt::If {
            cond,
            then_body: Box::new(then_body),
            else_body: Some(Box::new(else_body)),
        }
    },

    // While is open if its body is open
    // e.g.: `while (cond) if (cond2) stmt; else stmt2;`
    "while" "(" <cond: Expr> ")" <body: OpenStmt> => Stmt::While {
        cond,
        body: Box::new(body),
    },
}
```

### 2.3 主要设计考虑及算法选择

#### 2.3.1 符号表的设计考虑

每一级的符号表是一个 `SymbolTable` 结构体，它包装一个 `HashMap` 用于存储本级符号的信息，并**拥有所有权地持有**自己外一级符号表的指针。
- 各级符号表被组织为**链式结构**，**自然地实现了作用域嵌套和变量遮蔽**。
- 每级符号表只存本级符号信息，**空间利用高效**
- 进入新作用域时，调用 `enter_scope` 创建新的符号表作为当前符号表，并将其 `outer` 指针指向原符号表。退出作用域时，调用 `exit_scope` 方法将当前符号表替换为其外一级符号表。**所有权转换逻辑被封装**，**优雅地避免了复杂的 Rust 所有权和生命周期问题**

```rust
/// Outer table is owned by the current table
/// Top-level table has None as outer
/// Only the most inner table is owned by KoopaContext
pub struct SymbolTable {
    level: i32,                         // Scope level for variable shadowing
    table: HashMap<String, SymbolInfo>, // Symbol names DO NOT start with `@` or `%`!
    outer: Option<Box<SymbolTable>>,
}
```


#### 2.3.2 寄存器分配策略
如文档中所述，后端采用了**简单的栈上分配策略**，即在初始化函数栈帧时，为每个必要的 Koopa IR 值分配栈空间，并记录其栈偏移量。每次访问该值时，通过栈偏移量从栈中加载到寄存器，或将寄存器中的值存回栈中。

#### 2.3.3 采用的优化策略
- 常量折叠：在前端生成 Koopa IR 时，遇到常量表达式会直接计算其值并生成对应的常量，而非生成计算指令。
- 强度削减：在生成数组访问地址时，若遇到乘 2 的幂操作，会将乘法替换为移位操作。

#### 2.3.4 其它补充设计考虑

AST 节点设计：本编译器将**简洁扼要**确定为 AST 节点的设计目标，将语法分析阶段的冗余非终结符和逻辑封装在 lalrpop 语法定义中。例如，递归解析表达式的逻辑被封装在 lalrpop 语法定义中，AST 节点仅区分二元、一元、左值、函数调用和数字五种表达式类型。同样被封装在 lalrpop 语法定义中的还有 `if` 语句的二义性处理、多变量声明语句（如 `int a, b = 1, c;`）的解析等。

后端模块划分：本编译器将后端划分为**程序级翻译**和**函数级翻译**两个子模块。程序级翻译负责处理 Koopa IR 程序的整体结构，生成汇编文件的全局部分，并调用函数级翻译处理每个函数。函数级翻译负责处理单个函数的 Koopa IR，生成对应的汇编代码。这样的模块划分使得代码**结构清晰**，职责分明，**规避了复杂的 Rust 所有权和生命周期问题**，同时**为后续不同级别的优化提供了便利**。

数组初始化模块：本编译器在前端中实现了一个专门的数组初始化模块 `ArrayInitHelper`，负责封装复杂的数组初始化逻辑。这避免了前端翻译逻辑的臃肿，提高了代码的可读性和可维护性。



## 三、编译器实现

### 3.1 各阶段编码细节

#### Lv1. main函数和Lv2. 初试目标代码生成

无

#### Lv3. 表达式

如前所述，我将复杂且偏固定的表达式递归解析逻辑封装在 lalrpop 语法定义中，AST 节点仅区分二元、一元、左值、函数调用和数字五种表达式类型。这样使得前端翻译逻辑简洁明了，易于维护拓展。

#### Lv4. 常量和变量

本阶段的符号表设计，我在一开始就考虑到了作用域嵌套和变量遮蔽的问题，从而设计了链式结构的符号表。我认为最值得一提的是符号表的所有权设计：每一级符号表**拥有**自己外一级符号表的指针，这使得符号表的生命周期管理变得极为简单优雅。若使 `KoopaContext` 持有上级符号表的引用，则容易引发复杂的所有权和生命周期问题。


#### Lv5. 语句块和作用域

如前所述，链式结构的符号表可以非常优雅自然地实现作用域嵌套和变量遮蔽。

#### Lv6. if语句

如前所述，我在 lalrpop 语法定义中通过区分已匹配的语句和开放的语句来解决 `if...else...` 语句的二义性问题。并且此逻辑被很好地封装，在 AST 节点中只有一种统一的 `Stmt::If` 结构。

#### Lv7. while语句

我使用了栈结构来维护当前循环的 `break` 和 `continue` 目标基本块。在进入循环时，将新的 `break` 和 `continue` 目标基本块压入栈中；在退出循环时，将其弹出。这自然且比较优雅的解决了循环嵌套时 `break` 和 `continue` 目标的正确识别问题。

#### Lv8. 函数和全局变量

对于超过 8 个参数的函数调用，我在后端函数级翻译模块中实现了对多余参数的栈上分配和传递。具体来说，前 8 个参数仍然通过寄存器传递，而第 9 个及以后的参数则依次压入栈中。

#### Lv9. 数组

如前所述，我在前端中实现了一个专门的数组初始化模块 `ArrayInitHelper`，负责封装复杂的数组初始化逻辑。这避免了前端翻译逻辑的臃肿，提高了代码的可读性和可维护性。

此外，我在后端模块中也实现了 `generate_ptr_calc` 函数，用于计算数组索引对应的内存地址。

普通的数组和作为函数参数的数组，在地址计算方面上的逻辑是相似的，我最大限度地实现了代码复用，避免冗余。

### 3.2 工具软件介绍（若未使用特殊软件或库，则本部分可略过）

- 使用 Koopa IR 库作为编译器的中间表示。
- 使用 lalrpop 作为语法分析器生成工具。

### 3.3 测试情况说明（如果进行过额外的测试，可增加此部分内容）

无

## 四、实习总结

### 4.1 收获和体会

对 Rust 语言的掌握有了极大的进步，体会到了 Rust 在内存安全、模块化、面向对象设计等等方面的巨大优势，也体会到 Rust 对程序员在架构设计方面提出的更高要求（乱的架构设计和所有权/生命周期关系会使代码极容易发生编译错误）。

### 4.2 学习过程中的难点，以及对实习过程和内容的建议

对 Koopa IR 库的理解是我完成此 lab 的最大难点。我希望课程组提供更多关于 Koopa IR 库的示例指引和 high-level 的文档说明，帮助学生更快上手。

我希望课程组公开所有测试样例。本大作业已经具有很高的难度，且有优化阶段供进一步区分学生，不需要通过隐藏测试样例去做区分。被隐藏的测试样例无助于学生调试和完善自己的编译器，增加了很多不必要的痛苦。

### 4.3 对老师讲解内容与方式的建议

无