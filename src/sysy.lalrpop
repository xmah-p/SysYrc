grammar;

use crate::ast::*;

// lexer rules
match {
    r"\s*" => {},                // Ignore whitespace
    r"//[^\n\r]*[\n\r]*" => {},  // Ignore single-line comments
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => {}, // Ignore multi-line comments
    _                            // Default case: convert to token and pass to parser
}

// ==============================================
// Global
// ==============================================

// Non-teminal: Return Type = Match Pattern => Action Code
pub CompUnit: CompUnit = <items: GlobalItem*> => CompUnit { 
    items: items.into_iter().flatten().collect() 
};

GlobalItem: Vec<GlobalItem> = {
    <decls: Decl> => decls.into_iter().map(GlobalItem::Decl).collect(),
    <f: FuncDef> => vec![GlobalItem::FuncDef(f)],
};

FuncDef: FuncDef = {
    "void" <func_name: Ident> "(" <params: Comma<FuncFParam>> ")" <block: Block> => {
        FuncDef { func_type: FuncType::Void, func_name, params, block }
    },
    <t: DataType> <func_name: Ident> "(" <params: Comma<FuncFParam>> ")" <block: Block> => {
        FuncDef { func_type: t.into(), func_name, params, block }
    },
};

FuncArrayPart: Vec<Expr> = {
    "[" "]" <d:ArrayDims> => d
}

FuncFParam: FuncFParam = {
    <t: DataType> <id: Ident> <arr: FuncArrayPart?> => {
        FuncFParam {
            base_type: t,
            name: id,
            dims: arr,
        }
    }
}

// ==============================================
// Block
// ==============================================

// `*` returns a `Vec`
Block: Block = "{" <items: BlockItem*> "}" => Block { 
    items: items.into_iter().flatten().collect() 
};

BlockItem: Vec<BlockItem> = {
    <decls: Decl> => decls.into_iter().map(BlockItem::Decl).collect(),
    <stmt: Stmt> => vec![BlockItem::Stmt(stmt)], 
}

// Multiple declarations can be grouped together
// So Decl returns a Vec<Decl>
Decl: Vec<Decl> = {
    <c: ConstDecl> => c,
    <v: VarDecl> => v,
}

ConstDecl: Vec<Decl> = {
    "const" <vt: DataType> <defs: Comma<ConstDef>> ";" => defs
}

VarDecl: Vec<Decl> = {
    <vt: DataType> <defs: Comma<VarDef>> ";" => defs
}

DataType: DataType = {
    "int" => DataType::Int,
}


ConstDef: Decl = {
    <id: Ident> <dims: ArrayDims> "=" <val: ConstInitVal> => {
        if dims.is_empty() {
            Decl::Const {
                var_type: DataType::Int,
                var_name: id,
                init_list: val, 
            }
        } else {
            Decl::ConstArray {
                var_type: DataType::Int,
                var_name: id,
                dims: dims,
                init_list: Some(val),
            }
        }
    }
}

ConstExpr: Expr = {
    <e: Expr> => e,
}

VarDef: Decl = {
    // With initialization
    <id: Ident> <dims: ArrayDims> "=" <val: InitVal> => {
        if dims.is_empty() {
            Decl::Var {
                var_type: DataType::Int,
                var_name: id,
                init_list: Some(val), 
            }
        } else {
            Decl::Array {
                var_type: DataType::Int,
                var_name: id,
                dims: dims,
                init_list: Some(val),
            }
        }
    },

    // Without initialization
    <id: Ident> <dims: ArrayDims> => {
        if dims.is_empty() {
            Decl::Var {
                var_type: DataType::Int,
                var_name: id,
                init_list: None,
            }
        } else {
            Decl::Array {
                var_type: DataType::Int,
                var_name: id,
                dims: dims,
                init_list: None,
            }
        }
    }
}

InitVal: InitList = {
    <e: Expr> => InitList::Expr(e),
    "{" <list: Comma<InitVal>> "}" => InitList::List(list),
}

ConstInitVal: InitList = {
    <e: ConstExpr> => InitList::Expr(e),
    "{" <list: Comma<ConstInitVal>> "}" => InitList::List(list),
}

ArrayDim: Expr = "[" <e:ConstExpr> "]" => e;

ArrayDims: Vec<Expr> = ArrayDim*;

Index: Expr = "[" <e:Expr> "]" => e;

Indices: Vec<Expr> = Index*;

Comma<T>: Vec<T> = { 
    // (<T> ",")* 匹配 0 个或多个 "T," 
    // <e:T?>      匹配 0 个或 1 个 T (处理最后一个没有逗号的情况)
    <mut v:(<T> ",")*> <e:T?> => match e { 
        None => v, 
        Some(e) => { 
            v.push(e); 
            v 
        } 
    } 
};

// ==============================================
// Statement
// ==============================================

Stmt: Stmt = {
    MatchedStmt,
    OpenStmt,
}

MatchedStmt: Stmt = {
    "return" <expr: Expr> ";" => Stmt::Return { expr: Some(expr) },
    "return" ";" => Stmt::Return { expr: None },
    <lval: LVal> "=" <expr: Expr> ";" => Stmt::Assign {
        lval: lval,
        expr: expr,
    },
    ";" => Stmt::Expression { expr: None },
    <expr: Expr> ";" => Stmt::Expression { expr: Some(expr) },
    <block: Block> => Stmt::Block { block: block },
    "while" "(" <cond: Expr> ")" <body: MatchedStmt> => Stmt::While {
        cond,
        body: Box::new(body),
    },
    "break" ";" => Stmt::Break,
    "continue" ";" => Stmt::Continue,
    "if" "(" <cond: Expr> ")" <then_body: MatchedStmt> "else" <else_body: MatchedStmt> => Stmt::If {
        cond,
        then_body: Box::new(then_body),
        else_body: Some(Box::new(else_body)),
    },
};

OpenStmt: Stmt = {
    // Case A: No else
    // Only when there's no else, we can allow then_body to be OpenStmt
    "if" "(" <cond: Expr> ")" <then_body: Stmt> => {
        Stmt::If {
            cond,
            then_body: Box::new(then_body),
            else_body: None,
        }
    },

    // Case B: With else, but else_body is OpenStmt
    // then_body must be MatchedStmt here, otherwise else would be parsed as belonging to then_body
    // instead of the current if.
    "if" "(" <cond: Expr> ")" <then_body: MatchedStmt> "else" <else_body: OpenStmt> => {
        Stmt::If {
            cond,
            then_body: Box::new(then_body),
            else_body: Some(Box::new(else_body)),
        }
    },

    // While is open if its body is open
    // e.g.: `while (cond) if (cond2) stmt; else stmt2;`
    "while" "(" <cond: Expr> ")" <body: OpenStmt> => Stmt::While {
        cond,
        body: Box::new(body),
    },
}

// ==============================================
// Expression
// ==============================================
Expr: Expr = LOrExpr;

LOrExpr: Expr = {
    <lhs: LOrExpr> "||" <rhs: LAndExpr> => Expr::Binary {
        op: BinaryOp::Or,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    LAndExpr,
};

LAndExpr: Expr = {
    <lhs: LAndExpr> "&&" <rhs: EqExpr> => Expr::Binary {
        op: BinaryOp::And,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    EqExpr,
};

EqExpr: Expr = {
    <lhs: EqExpr> "==" <rhs: RelExpr> => Expr::Binary {
        op: BinaryOp::Eq,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs: EqExpr> "!=" <rhs: RelExpr> => Expr::Binary {
        op: BinaryOp::Neq,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    RelExpr,
};

RelExpr: Expr = {
    <lhs: RelExpr> "<" <rhs: AddExpr> => Expr::Binary {
        op: BinaryOp::Lt,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs: RelExpr> ">" <rhs: AddExpr> => Expr::Binary {
        op: BinaryOp::Gt,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs: RelExpr> "<=" <rhs: AddExpr> => Expr::Binary {
        op: BinaryOp::Leq,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs: RelExpr> ">=" <rhs: AddExpr> => Expr::Binary {
        op: BinaryOp::Geq,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    AddExpr,
};

AddExpr: Expr = {
    <lhs: AddExpr> "+" <rhs: MulExpr> => Expr::Binary {
        op: BinaryOp::Add,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs: AddExpr> "-" <rhs: MulExpr> => Expr::Binary {
        op: BinaryOp::Sub,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    MulExpr,
};

MulExpr: Expr = {
    <lhs: MulExpr> "*" <rhs: UnaryExpr> => Expr::Binary {
        op: BinaryOp::Mul,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs: MulExpr> "/" <rhs: UnaryExpr> => Expr::Binary {
        op: BinaryOp::Div,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    <lhs: MulExpr> "%" <rhs: UnaryExpr> => Expr::Binary {
        op: BinaryOp::Mod,
        lhs: Box::new(lhs),
        rhs: Box::new(rhs),
    },
    UnaryExpr,
};

UnaryExpr: Expr = {
    <op: UnaryOp> <expr: UnaryExpr> => Expr::Unary {
        op: op,
        expr: Box::new(expr),
    },
    <func_name: Ident> "(" <args: Comma<Expr>> ")" => Expr::Call {
        func_name,
        args,
    },
    PrimaryExpr,
};

PrimaryExpr: Expr = {
    "(" <Expr> ")",
    <lval: LVal> => lval,
    <num:Number> => Expr::Number(num),
}

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Pos,
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
};

BinaryOp: BinaryOp = {
    "||" => BinaryOp::Or,
    "&&" => BinaryOp::And,
    "==" => BinaryOp::Eq,
    "!=" => BinaryOp::Neq,
    "<"  => BinaryOp::Lt,
    ">"  => BinaryOp::Gt,
    "<=" => BinaryOp::Leq,
    ">=" => BinaryOp::Geq,
    "+"  => BinaryOp::Add,
    "-"  => BinaryOp::Sub,
    "*"  => BinaryOp::Mul,
    "/"  => BinaryOp::Div,
    "%"  => BinaryOp::Mod,
};

LVal: Expr = {
    <id: Ident> <idxs: Indices> => Expr::LVal { name: id, indices: if idxs.is_empty() { None } else { Some(idxs) } },
}

Number: i32 = <num: IntConst> => <>;

// <> stands for the matched text slice &str
// to_string() converts this &str to an owned String
Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),                // decimal
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),                     // octal
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),    // hexadecimal
}
